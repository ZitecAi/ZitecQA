# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true
  repositories:
    - repository: testsRepo
      type: git
      name: Dev-ops IDSF/PortalIDSFTestes
      ref: refs/heads/main

variables:
  - group: NetlifySecrets
  - group: EmailSecrets
  - name: TEST_CSPROJ
    value: 'tests/PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'tests/PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

jobs:
  # =========================
  # JOB 1 ‚Äî TESTS (n√£o bloqueia)
  # =========================
  - job: Tests
    displayName: "Run Playwright/NUnit tests (latest main)"
    pool:
      vmImage: 'ubuntu-22.04'

    steps:
      - checkout: none

      - checkout: testsRepo
        displayName: 'Checkout tests repo (main)'
        path: tests
        clean: true
        fetchDepth: 0   # <<< sem aspas, para garantir clone completo

      # For√ßa HEAD exatamente na √∫ltima origin/main
      - script: |
          set -e
          cd tests
          git fetch origin main --prune
          git checkout -f main
          git reset --hard origin/main
          echo "HEAD em:"
          git log -1 --pretty=oneline
        displayName: 'Force latest origin/main (hard reset)'

      - task: UseDotNet@2
        displayName: 'Use .NET 8 SDK'
        inputs:
          packageType: 'sdk'
          version: '8.0.x'

      - task: NodeTool@0
        displayName: 'Use Node 18'
        inputs:
          versionSpec: '18.x'

      - script: |
          set -e
          dotnet --info
          dotnet restore "$(TEST_CSPROJ)"
          dotnet build "$(TEST_CSPROJ)" -c Release --no-restore
        displayName: 'Restore + Build'

      - script: |
          set -e
          cd "$(TEST_DIR)"

          SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
          if [ -z "$SCRIPT_PATH" ]; then
            echo "ERRO: playwright.ps1 n√£o encontrado ap√≥s o build."
            ls -R ./bin || true
            exit 1
          fi

          echo "Usando script: $SCRIPT_PATH"
          if ! pwsh "$SCRIPT_PATH" install --with-deps; then
            echo "Aviso: --with-deps falhou. Tentando 'install' sem deps..."
            pwsh "$SCRIPT_PATH" install
          fi
        displayName: 'Playwright browsers install (project script)'

      # Garante que os resultados ser√£o SEMPRE de agora (dir limpo)
      - script: |
          set -e
          ROOT="$(System.DefaultWorkingDirectory)/tests"
          ALLURE_ROOT="$ROOT/_allure"
          rm -rf "$ALLURE_ROOT"
          mkdir -p "$ALLURE_ROOT/results"

          cat > "$ROOT/allure.config.json" <<'EOF'
          {
            "allure": {
              "directory": "_allure/results"
            }
          }
          EOF
        displayName: 'Clean e configurar Allure results dir'

      - script: |
          set +e
          echo "Rodando testes em: $(TEST_CSPROJ)"
          export ALLURE_CONFIG="$(System.DefaultWorkingDirectory)/tests/allure.config.json"
          dotnet test "$(TEST_CSPROJ)" -c Release \
            --logger "trx;LogFileName=$(System.DefaultWorkingDirectory)/tests/TestResults/results.trx"
          TEST_EXIT=$?
          echo "Exit code dos testes: $TEST_EXIT"
          echo "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$TEST_EXIT"
          echo "Arquivos gerados em _allure/results:"
          ls -la "$(System.DefaultWorkingDirectory)/tests/_allure/results" || true
          exit 0
        name: runTests
        displayName: 'Run tests (non-blocking)'

      - task: PublishTestResults@2
        displayName: 'Publish TRX'
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: 'tests/TestResults/**/*.trx'
          searchFolder: '$(System.DefaultWorkingDirectory)'
          failTaskOnFailedTests: false
          testRunTitle: 'NUnit TRX'
          mergeTestResults: true

      - task: PublishPipelineArtifact@1
        displayName: 'Publish artifact: allure-results'
        inputs:
          artifact: 'allure-results'
          targetPath: '$(System.DefaultWorkingDirectory)/tests/_allure/results'

  # =========================
  # JOB 2 ‚Äî REPORT (sempre roda)
  # =========================
  - job: Report
    displayName: "Generate & publish Allure + Send email"
    pool:
      vmImage: 'ubuntu-22.04'
    dependsOn: Tests
    condition: always()

    variables:
      TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]

    steps:
      - download: current
        displayName: 'Download artifact: allure-results'
        artifact: 'allure-results'

      - task: NodeTool@0
        displayName: 'Use Node 18'
        inputs:
          versionSpec: '18.x'

      # Gera site; limpa QUALQUER hist√≥rico antes de publicar "latest"
      - script: |
          set -e
          npm i -g allure-commandline netlify-cli

          SRC="$(Pipeline.Workspace)/allure-results"
          SITE="_site"
          LATEST="$SITE/latest"
          VERSIONED="$SITE/builds/$(Build.BuildId)"
          TMP="allure-tmp"

          rm -rf "$TMP" "$LATEST" "$VERSIONED"
          mkdir -p "$TMP" "$LATEST" "$VERSIONED" "$SITE"

          if [ -d "$SRC" ] && [ "$(ls -A "$SRC" 2>/dev/null)" ]; then
            echo "Gerando Allure..."
            allure generate --clean -o "$TMP" "$SRC" || true
          fi

          # >>> Remove qualquer 'history' do Allure para n√£o reaproveitar data/trend
          rm -rf "$TMP/history" || true
          find "$TMP" -type f -name 'history.json' -delete || true
          find "$TMP" -type f -name '*history-trend*.json' -delete || true

          if [ ! -d "$TMP" ] || [ -z "$(ls -A "$TMP" 2>/dev/null)" ]; then
            echo "Criando placeholder..."
            mkdir -p "$TMP"
            cat > "$TMP/index.html" <<'HTML'
            <!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Allure - Placeholder</title></head><body style="font-family:Arial,Helvetica,sans-serif;padding:24px"><h1>Allure Report</h1><p>N√£o h√° resultados de teste dispon√≠veis para esta execu√ß√£o, ou a gera√ß√£o do Allure falhou.</p></body></html>
            HTML
          fi

          # >>> latest SEMPRE sobrescreve (rsync --delete)
          rsync -a --delete "$TMP/" "$LATEST/"
          # mant√©m vers√£o da execu√ß√£o
          rsync -a "$TMP/" "$VERSIONED/"

          # Index com links
          cat > "$SITE/index.html" <<HTML
          <!doctype html><html lang="pt-br"><head><meta charset="utf-8">
          <title>Relat√≥rios Allure</title>
          <style>body{font-family:Arial,Helvetica,sans-serif;padding:24px} a{display:block;margin:.4rem 0}</style>
          </head><body>
          <h1>Relat√≥rios Allure</h1>
          <p><a href="./latest/">üîó √öltimo relat√≥rio (latest)</a></p>
          <h2>Hist√≥rico por execu√ß√£o</h2>
          <ul>
            <li><a href="./builds/$(Build.BuildId)/">Build $(Build.BuildNumber) ‚Äî ID $(Build.BuildId)</a></li>
          </ul>
          </body></html>
          HTML

          # Cabe√ßalhos no-cache
          cat > "$SITE/_headers" <<'HDR'
          /*
          cache-control: max-age=0
          cache-control: no-cache
          cache-control: no-store
          cache-control: must-revalidate
          HDR
        displayName: 'Generate versioned site (_site/latest and _site/builds/<id>)'
        condition: always()

      - script: |
          set -e
          netlify deploy \
            --prod \
            --dir="_site" \
            --site "$(NETLIFY_SITE_ID)" \
            --auth "$(NETLIFY_AUTH_TOKEN)" \
            --message "Allure $(Build.BuildNumber)" \
            --json > deploy.json

          echo "======== Netlify Deploy Result ========"
          cat deploy.json || true

          URL=$(node -e "let d='';process.stdin.on('data',c=>d+=c).on('end',()=>{try{let j=JSON.parse(d);console.log(j.deploy_ssl_url||j.deploy_url||j.url||j.site_url||'');}catch(e){}})" < deploy.json)
          echo "##vso[task.setvariable variable=NETLIFY_URL]$URL"
        displayName: 'Deploy to Netlify (prod)'
        condition: always()

      - script: |
          set -e
          netlify api purgeCache --auth "$(NETLIFY_AUTH_TOKEN)" \
            --data '{"site_id":"'"$(NETLIFY_SITE_ID)"'"}' || true
        displayName: 'Purge Netlify CDN cache'
        condition: always()

      - task: PowerShell@2
        displayName: 'Send email with report links'
        condition: always()
        env:
          SITE_URL: $(SITE_URL)
          NETLIFY_URL: $(NETLIFY_URL)
          SMTP_SERVER: $(SMTP_SERVER)
          SMTP_PORT: $(SMTP_PORT)
          SMTP_USER: $(SMTP_USER)
          SMTP_PASS: $(SMTP_PASS)
          MAIL_FROM: $(MAIL_FROM)
          MAIL_TO: $(MAIL_TO)
          TEST_EXIT: $(TEST_EXIT_FROM_PREV)
          BUILD_DEFINITIONNAME: $(Build.DefinitionName)
          BUILD_BUILDID: $(Build.BuildId)
          BUILD_BUILDNUMBER: $(Build.BuildNumber)
        inputs:
          targetType: inline
          script: |
            $siteUrl = $env:NETLIFY_URL
            if ([string]::IsNullOrWhiteSpace($siteUrl)) { $siteUrl = $env:SITE_URL }

            $latest = "$siteUrl/latest/"
            $this   = "$siteUrl/builds/$($env:BUILD_BUILDID)/"

            $pipeline = $env:BUILD_DEFINITIONNAME
            $buildId  = $env:BUILD_BUILDID
            $buildNum = $env:BUILD_BUILDNUMBER
            $testExit = $env:TEST_EXIT
            if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }

            $subject = "Relat√≥rio Allure (Staging) - $status"
            $bodyLines = @(
              "Pipeline: $pipeline",
              "Execu√ß√£o: $buildNum (ID $buildId)",
              "Status dos testes: $status (exit $testExit)",
              "Relat√≥rio (latest): $latest",
              "Relat√≥rio desta execu√ß√£o: $this"
            )
            $body = $bodyLines -join "`n"

            if ($env:SMTP_USER -and $env:SMTP_PASS) {
              $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
              Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
            } else {
              Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
            }
