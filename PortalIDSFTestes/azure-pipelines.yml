# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true
  repositories:
    - repository: testsRepo
      type: git
      name: Dev-ops IDSF/PortalIDSFTestes
      ref: refs/heads/main

variables:
  - group: NetlifySecrets
  - group: EmailSecrets
  - name: TEST_CSPROJ
    value: 'tests/PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'tests/PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

jobs:
  # =========================
  # JOB 1 ‚Äî TESTS (n√£o bloqueia)
  # =========================
  - job: Tests
    displayName: "Run Playwright/NUnit tests (latest main)"
    pool:
      vmImage: 'ubuntu-22.04'
    steps:
      - checkout: none

      - checkout: testsRepo
        displayName: 'Checkout tests repo (main)'
        path: tests
        clean: true
        fetchDepth: 0

      - script: |
          set -e
          cd tests
          git fetch origin main --prune
          git checkout -f main
          git reset --hard origin/main
          echo "HEAD em:"
          git log -1 --pretty=oneline
        displayName: 'Force latest origin/main (hard reset)'

      - task: UseDotNet@2
        displayName: 'Use .NET 8 SDK'
        inputs:
          packageType: 'sdk'
          version: '8.0.x'

      - task: NodeTool@0
        displayName: 'Use Node 18'
        inputs:
          versionSpec: '18.x'

      - script: |
          set -e
          dotnet clean "$(TEST_CSPROJ)" -c Release
          rm -rf "$(TEST_DIR)/bin" "$(TEST_DIR)/obj" "$(System.DefaultWorkingDirectory)/tests/TestResults"
        displayName: 'Clean bin/obj/TestResults (build 100% novo)'

      - script: |
          set -e
          dotnet --info
          dotnet restore "$(TEST_CSPROJ)"
          dotnet build "$(TEST_CSPROJ)" -c Release --no-restore
        displayName: 'Restore + Build'

      - script: |
          set -e
          cd "$(TEST_DIR)"
          SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
          if [ -z "$SCRIPT_PATH" ]; then
            echo "ERRO: playwright.ps1 n√£o encontrado ap√≥s o build."
            ls -R ./bin || true
            exit 1
          fi
          echo "Usando script: $SCRIPT_PATH"
          if ! pwsh "$SCRIPT_PATH" install --with-deps; then
            echo "Aviso: --with-deps falhou. Tentando 'install' sem deps..."
            pwsh "$SCRIPT_PATH" install
          fi
        displayName: 'Playwright browsers install (project script)'

      - script: |
          set -e
          ROOT="$(System.DefaultWorkingDirectory)/tests"
          ALLURE_ROOT="$ROOT/_allure"
          rm -rf "$ALLURE_ROOT"
          mkdir -p "$ALLURE_ROOT/results"

          # Cria allure.config.json com caminho absoluto
          printf '%s\n' \
            '{' \
            '  "allure": {' \
            "    \"directory\": \"${ALLURE_ROOT}/results\"" \
            '  }' \
            '}' > "$ROOT/allure.config.json"
        displayName: 'Clean e configurar Allure (path absoluto)'

      - script: |
          set +e
          echo "Rodando testes em: $(TEST_CSPROJ)"
          dotnet test "$(TEST_CSPROJ)" -c Release \
            --logger "trx;LogFileName=$(System.DefaultWorkingDirectory)/tests/TestResults/results.trx"
          TEST_EXIT=$?
          echo "Exit code dos testes: $TEST_EXIT"
          echo "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$TEST_EXIT"
          echo "Arquivos em _allure/results:"
          ls -la "$(System.DefaultWorkingDirectory)/tests/_allure/results" || true
          grep -R --include='*.json' -m 1 '"start"' "$(System.DefaultWorkingDirectory)/tests/_allure/results" || true
          exit 0
        name: runTests
        displayName: 'Run tests (non-blocking)'
        env:
          ALLURE_CONFIG: $(System.DefaultWorkingDirectory)/tests/allure.config.json
          ALLURE_RESULTS_DIRECTORY: $(System.DefaultWorkingDirectory)/tests/_allure/results

      - task: PublishTestResults@2
        displayName: 'Publish TRX'
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: 'tests/TestResults/**/*.trx'
          searchFolder: '$(System.DefaultWorkingDirectory)'
          failTaskOnFailedTests: false
          testRunTitle: 'NUnit TRX'
          mergeTestResults: true

      - task: PublishPipelineArtifact@1
        displayName: 'Publish artifact: allure-results'
        inputs:
          artifact: 'allure-results'
          targetPath: '$(System.DefaultWorkingDirectory)/tests/_allure/results'

  # =========================
  # JOB 2 ‚Äî REPORT (sempre roda)
  # =========================
  - job: Report
    displayName: "Generate & publish Allure + Send email"
    pool:
      vmImage: 'ubuntu-22.04'
    dependsOn: Tests
    condition: always()
    variables:
      TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]
    steps:
      - download: current
        displayName: 'Download artifact: allure-results'
        artifact: 'allure-results'

      - task: NodeTool@0
        displayName: 'Use Node 18'
        inputs:
          versionSpec: '18.x'

      - script: |
          set -e
          npm i -g allure-commandline netlify-cli

          SRC="$(Pipeline.Workspace)/allure-results"
          SITE="_site"
          LATEST="$SITE/latest"
          VERSIONED="$SITE/builds/$(Build.BuildId)"
          TMP="allure-tmp"

          rm -rf "$SITE" "$TMP"
          mkdir -p "$TMP" "$LATEST" "$VERSIONED" "$SITE"

          if [ -d "$SRC" ] && [ "$(ls -A "$SRC" 2>/dev/null)" ]; then
            echo "Gerando Allure..."
            allure generate --clean -o "$TMP" "$SRC" || true
          fi

          # Remove hist√≥rico para o 'latest' n√£o herdar datas antigas
          rm -rf "$TMP/history" || true
          find "$TMP" -type f -name 'history.json' -delete || true
          find "$TMP" -type f -name '*history-trend*.json' -delete || true

          # Placeholder se n√£o gerou
          if [ ! -d "$TMP" ] || [ -z "$(ls -A "$TMP" 2>/dev/null)" ]; then
            mkdir -p "$TMP"
            printf '%s\n' \
              '<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Allure - Placeholder</title></head><body style="font-family:Arial,Helvetica,sans-serif;padding:24px"><h1>Allure Report</h1><p>N√£o h√° resultados de teste dispon√≠veis para esta execu√ß√£o, ou a gera√ß√£o do Allure falhou.</p></body></html>' \
              > "$TMP/index.html"
          fi

          # latest sempre substitui TUDO
          rsync -a --delete "$TMP/" "$LATEST/"
          # guarda vers√£o por build
          rsync -a "$TMP/" "$VERSIONED/"

          # Hash do summary local (para checagem ap√≥s deploy)
          if [ -f "$LATEST/widgets/summary.json" ]; then
            sha1sum "$LATEST/widgets/summary.json" | awk '{print $1}' > local_summary.sha1
          fi

          # index.html do site
          printf '%s\n' \'<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Relat√≥rios Allure</title><style>body{font-family:Arial,Helvetica,sans-serif;padding:24px} a{display:block;margin:.4rem 0}</style></head><body>' \'<h1>Relat√≥rios Allure</h1>' \'<p><a href="./latest/">üîó √öltimo relat√≥rio (latest)</a></p>' \'<h2>Hist√≥rico por execu√ß√£o</h2>' \'<ul>' \"<li><a href=\"./builds/$(Build.BuildId)/\">Build $(Build.BuildNumber) ‚Äî ID $(Build.BuildId)</a></li>" \'</ul>' \'</body></html>' \
          > "$SITE/index.html"

          # _headers para no-cache
          {
            echo '/*'
            echo 'cache-control: max-age=0'
            echo 'cache-control: no-cache'
            echo 'cache-control: no-store'
            echo 'cache-control: must-revalidate'
          } > "$SITE/_headers"
        displayName: 'Generate versioned site (_site/latest and _site/builds/<id>)'
        condition: always()

      - script: |
          set -e
          netlify deploy \
            --prod \
            --dir="_site" \
            --site "$(NETLIFY_SITE_ID)" \
            --auth "$(NETLIFY_AUTH_TOKEN)" \
            --message "Allure $(Build.BuildNumber)" \
            --json > deploy.json

          echo "======== Netlify Deploy Result ========"
          cat deploy.json || true

          STATE=$(node -e "let d=require('fs').readFileSync('deploy.json','utf8');let j=JSON.parse(d);console.log(j.state||j.deploy_state||'');")
          if [ "$STATE" != "ready" ]; then
            echo "ERRO: deploy state = '$STATE' (n√£o √© 'ready')."
            exit 1
          fi

          URL=$(node -e "let d=require('fs').readFileSync('deploy.json','utf8');let j=JSON.parse(d);console.log(j.deploy_ssl_url||j.deploy_url||j.url||j.site_url||'');")
          echo "##vso[task.setvariable variable=NETLIFY_URL]$URL"
          echo "Publicado em: $URL"
        displayName: 'Deploy to Netlify (prod)'
        condition: always()

      - script: |
          set -e
          if [ -s local_summary.sha1 ]; then
            echo "Baixando summary publicado para comparar..."
            curl -fsSL "$(NETLIFY_URL)/latest/widgets/summary.json" -o remote_summary.json || true
            if [ -s remote_summary.json ]; then
              REMOTE_HASH=$(sha1sum remote_summary.json | awk '{print $1}')
              LOCAL_HASH=$(cat local_summary.sha1)
              echo "LOCAL : $LOCAL_HASH"
              echo "REMOTE: $REMOTE_HASH"
              if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
                echo "ATEN√á√ÉO: summary em produ√ß√£o difere do local (pode ser cache/CDN ou deploy antigo)."
                false || true
              else
                echo "OK: summary em produ√ß√£o bate com o local."
              fi
            else
              echo "WARN: n√£o consegui baixar o summary publicado."
            fi
          else
            echo "Sem hash local para comparar."
          fi
        displayName: 'Verificar conte√∫do publicado (hash do summary)'
        condition: always()

      - script: |
          set -e
          netlify api purgeCache --auth "$(NETLIFY_AUTH_TOKEN)" \
            --data '{"site_id":"'"$(NETLIFY_SITE_ID)"'"}' || true
        displayName: 'Purge Netlify CDN cache'
        condition: always()

      - task: PowerShell@2
        displayName: 'Send email with report links'
        condition: always()
        env:
          SITE_URL: $(SITE_URL)
          NETLIFY_URL: $(NETLIFY_URL)
          SMTP_SERVER: $(SMTP_SERVER)
          SMTP_PORT: $(SMTP_PORT)
          SMTP_USER: $(SMTP_USER)
          SMTP_PASS: $(SMTP_PASS)
          MAIL_FROM: $(MAIL_FROM)
          MAIL_TO: $(MAIL_TO)
          TEST_EXIT: $(TEST_EXIT_FROM_PREV)
          BUILD_DEFINITIONNAME: $(Build.DefinitionName)
          BUILD_BUILDID: $(Build.BuildId)
          BUILD_BUILDNUMBER: $(Build.BuildNumber)
        inputs:
          targetType: inline
          script: |
            $siteUrl = $env:NETLIFY_URL
            if ([string]::IsNullOrWhiteSpace($siteUrl)) { $siteUrl = $env:SITE_URL }
            $latest = "$siteUrl/latest/"
            $this   = "$siteUrl/builds/$($env:BUILD_BUILDID)/"
            $pipeline = $env:BUILD_DEFINITIONNAME
            $buildId  = $env:BUILD_BUILDID
            $buildNum = $env:BUILD_BUILDNUMBER
            $testExit = $env:TEST_EXIT
            if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }
            $subject = "Relat√≥rio Allure (Staging) - $status"
            $bodyLines = @(
              "Pipeline: $pipeline",
              "Execu√ß√£o: $buildNum (ID $buildId)",
              "Status dos testes: $status (exit $testExit)",
              "Relat√≥rio (latest): $latest",
              "Relat√≥rio desta execu√ß√£o: $this"
            )
            $body = $bodyLines -join "`n"
            if ($env:SMTP_USER -and $env:SMTP_PASS) {
              $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
              Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
            } else {
              Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
            }
