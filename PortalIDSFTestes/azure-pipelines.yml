# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true
  repositories:
    # ==> REPO DOS TESTES, sempre em main
    - repository: testsRepo
      type: git
      name: Dev-ops IDSF/PortalIDSFTestes          # <== ajuste para o nome exato do repo
      ref: refs/heads/main                         # força última main

variables:
  - group: NetlifySecrets
  - group: EmailSecrets
  - name: TEST_CSPROJ
    value: 'tests/PortalIDSFTestes/PortalIDSFTestes.csproj'   # path com prefixo "tests/"
  - name: TEST_DIR
    value: 'tests/PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

jobs:
# =========================
# JOB 1 — TESTS (não bloqueia)
# =========================
- job: Tests
  displayName: "Run Playwright/NUnit tests (latest main)"
  pool:
    vmImage: 'ubuntu-22.04'

  steps:
  # Se você não precisa do repo atual, evite checkout do self
  - checkout: none

  # Checkout do repositório de testes na última main
  - checkout: testsRepo
    displayName: 'Checkout tests repo (main)'
    path: tests                   # faz o repo cair na pasta ./tests
    clean: true
    fetchDepth: 0                 # garante histórico (útil pro Playwright script discovery etc.)

  - task: UseDotNet@2
    displayName: 'Use .NET 8 SDK'
    inputs:
      packageType: 'sdk'
      version: '8.0.x'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  - script: |
      set -e
      dotnet --info
      dotnet restore "$(TEST_CSPROJ)"
      dotnet build   "$(TEST_CSPROJ)" -c Release --no-restore
    displayName: 'Restore + Build'

  - script: |
      set -e
      cd "$(TEST_DIR)"

      SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
      if [ -z "$SCRIPT_PATH" ]; then
        echo "ERRO: playwright.ps1 não encontrado após o build."
        ls -R ./bin || true
        exit 1
      fi

      echo "Usando script: $SCRIPT_PATH"
      if ! pwsh "$SCRIPT_PATH" install --with-deps; then
        echo "Aviso: --with-deps falhou. Tentando 'install' sem deps..."
        pwsh "$SCRIPT_PATH" install
      fi
    displayName: 'Playwright browsers install (project script)'

  - script: |
      set -e
      # Gere config e resultados fora do repo para facilitar publicação depois
      ROOT="$(pwd)"
      ALLURE_ROOT="$ROOT/_allure"
      rm -rf "$ALLURE_ROOT"
      mkdir -p "$ALLURE_ROOT/results"

      cat > "$ROOT/allure.config.json" <<EOF
      {
        "allure": {
          "directory": "$ALLURE_ROOT/results"
        }
      }
      EOF
    displayName: 'Clean e configurar Allure results dir'

  - script: |
      set +e
      echo "Rodando testes em: $(TEST_CSPROJ)"
      ALLURE_CONFIG="$(System.DefaultWorkingDirectory)/tests/allure.config.json" \
      dotnet test "$(TEST_CSPROJ)" -c Release \
        --logger "trx;LogFileName=$(System.DefaultWorkingDirectory)/tests/TestResults/results.trx"
      TEST_EXIT=$?
      echo "Exit code dos testes: $TEST_EXIT"
      echo "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$TEST_EXIT"
      exit 0
    name: runTests
    displayName: 'Run tests (non-blocking)'

  - task: PublishTestResults@2
    displayName: Publish TRX
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: 'tests/TestResults/**/*.trx'
      searchFolder: '$(System.DefaultWorkingDirectory)'
      failTaskOnFailedTests: false
      testRunTitle: 'NUnit TRX'
      mergeTestResults: true

  - task: PublishPipelineArtifact@1
    displayName: 'Publish artifact: allure-results'
    inputs:
      artifact: 'allure-results'
      targetPath: '$(System.DefaultWorkingDirectory)/tests/_allure/results'

# =========================
# JOB 2 — REPORT (sempre roda)
# =========================
- job: Report
  displayName: "Generate & publish Allure + Send email"
  pool:
    vmImage: 'ubuntu-22.04'
  dependsOn: Tests
  condition: always()

  variables:
    TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]

  steps:
  - download: current
    displayName: 'Download artifact: allure-results'
    artifact: 'allure-results'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  - script: |
      set -e
      npm i -g allure-commandline netlify-cli

      SRC="$(Pipeline.Workspace)/allure-results"
      OUT="$(ALLURE_REPORT_DIR)"

      rm -rf "$OUT"
      mkdir -p "$OUT"

      if [ -d "$SRC" ] && [ "$(ls -A "$SRC" 2>/dev/null)" ]; then
        allure generate --clean -o "$OUT" "$SRC" || true
      fi

      if [ ! -d "$OUT" ] || [ -z "$(ls -A "$OUT" 2>/dev/null)" ]; then
        mkdir -p "$OUT"
        cat > "$OUT/index.html" <<'HTML'<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Allure - Placeholder</title></head><body style="font-family:Arial,Helvetica,sans-serif;padding:24px"><h1>Allure Report</h1><p>Não há resultados de teste disponíveis para esta execução, ou a geração do Allure falhou.</p></body></html>HTML
      fi

      cat > "$OUT/_headers" <<'HDR'/*cache-control: max-age=0cache-control: no-cachecache-control: no-storecache-control: must-revalidateHDR
    displayName: 'Generate Allure report (from artifact) + no-cache headers'

  - script: |
      set -e
      netlify deploy \
        --prod \
        --dir="$(ALLURE_REPORT_DIR)" \
        --site "$(NETLIFY_SITE_ID)" \
        --auth "$(NETLIFY_AUTH_TOKEN)" \
        --message "Allure $(Build.BuildNumber)" \
        --json > deploy.json

      echo "======== Netlify Deploy Result ========"
      cat deploy.json || true

      URL=$(node -e "let d='';process.
