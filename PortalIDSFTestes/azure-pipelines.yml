# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true

pool:
  vmImage: 'ubuntu-22.04'

variables:
  - group: NetlifySecrets
  - group: EmailSecrets
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

steps:
- checkout: self
  displayName: 'Checkout tests repo'

- task: UseDotNet@2
  displayName: 'Use .NET 8 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

- task: NodeTool@0
  displayName: 'Use Node 18'
  inputs:
    versionSpec: '18.x'

# Restore + Build
- script: |
    dotnet --info
    dotnet restore "$(TEST_CSPROJ)"
    dotnet build "$(TEST_CSPROJ)" -c Release --no-restore
  displayName: 'Restore + Build'

# Playwright browsers install (project script)
- script: |
    set -e
    cd "$(TEST_DIR)"

    SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
    if [ -z "$SCRIPT_PATH" ]; then
      echo "ERRO: playwright.ps1 não encontrado após o build."
      ls -R ./bin || true
      exit 1
    fi

    echo "Usando script: $SCRIPT_PATH"
    if ! pwsh "$SCRIPT_PATH" install --with-deps; then
      echo "Aviso: --with-deps falhou. Tentando 'install' sem deps..."
      pwsh "$SCRIPT_PATH" install
    fi
  displayName: 'Playwright browsers install (project script)'

# Run tests — captura exit code, marca status visual e SEMPRE sai 0
- script: |
    set +e
    echo "Rodando testes em: $(TEST_CSPROJ)"
    dotnet test "$(TEST_CSPROJ)" -c Release --logger "trx;LogFileName=$(Build.SourcesDirectory)/TestResults/results.trx"
    TEST_EXIT=$?
    echo "Exit code dos testes: $TEST_EXIT"
    echo "##vso[task.setvariable variable=TEST_EXIT]$TEST_EXIT"

    # Deixa o passo como 'SucceededWithIssues' se houve falhas (puro visual),
    # mas sem travar o job.
    if [ "$TEST_EXIT" -ne 0 ]; then
      echo "##vso[task.complete result=SucceededWithIssues;]Há testes falhando, mas o fluxo continuará."
    fi

    exit 0
  displayName: 'Run tests (non-blocking)'

# Allure (sempre executa; gera placeholder se não houver resultados)
- script: |
    set -e
    npm i -g allure-commandline netlify-cli

    # Tenta achar o allure-results gerado pelo adaptador
    RESULTS_FROM=$(find "$(TEST_DIR)/bin/Release" -type d -name "$(ALLURE_RESULTS_DIR)" | head -n 1 || true)
    if [ -n "$RESULTS_FROM" ] && [ ! -d "$(ALLURE_RESULTS_DIR)" ]; then
      echo "Copiando resultados de: $RESULTS_FROM"
      cp -r "$RESULTS_FROM" "./$(ALLURE_RESULTS_DIR)"
    fi

    if [ -d "$(ALLURE_RESULTS_DIR)" ] && [ "$(ls -A "$(ALLURE_RESULTS_DIR)" 2>/dev/null)" ]; then
      echo "Gerando Allure a partir de '$(ALLURE_RESULTS_DIR)'..."
      allure generate --clean -o "$(ALLURE_REPORT_DIR)" "$(ALLURE_RESULTS_DIR)" || true
    fi

    # Placeholder se não houver relatório
    if [ ! -d "$(ALLURE_REPORT_DIR)" ] || [ -z "$(ls -A "$(ALLURE_REPORT_DIR)" 2>/dev/null)" ]; then
      echo "Criando relatório placeholder..."
      mkdir -p "$(ALLURE_REPORT_DIR)"
      echo '<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Allure - Placeholder</title></head><body style="font-family:Arial,Helvetica,sans-serif;padding:24px"><h1>Allure Report</h1><p>Não há resultados de teste disponíveis para esta execução, ou a geração do Allure falhou.</p><ul><li>Verifique a etapa de testes (TRX publicado) para detalhes.</li><li>Confirme o output do adaptador Allure (pasta <code>allure-results</code>).</li></ul></body></html>' > "$(ALLURE_REPORT_DIR)/index.html"
    fi
  displayName: 'Generate Allure report'
  condition: always()

# Deploy no Netlify (sempre)
- script: |
    set -e
    netlify deploy \
      --prod \
      --dir="$(ALLURE_REPORT_DIR)" \
      --site "$(NETLIFY_SITE_ID)" \
      --auth "$(NETLIFY_AUTH_TOKEN)" \
      --json > deploy.json

    echo "======== Netlify Deploy Result ========"
    cat deploy.json || true
  displayName: 'Deploy to Netlify (prod)'
  condition: always()

# E-mail (sempre) — inclui status real dos testes
- task: PowerShell@2
  displayName: 'Send email with report link (plain text)'
  condition: always()
  inputs:
    targetType: inline
    script: |
      $siteUrl   = "$(SITE_URL)"
      $pipeline  = "$(Build.DefinitionName)"
      $buildId   = "$(Build.BuildId)"
      $buildNum  = "$(Build.BuildNumber)"
      $testExit  = "$(TEST_EXIT)"

      $smtpHost  = "$(SMTP_SERVER)"
      $smtpPort  = [int]"$(SMTP_PORT)"
      $smtpUser  = "$(SMTP_USER)"
      $smtpPass  = "$(SMTP_PASS)"
      $mailFrom  = "$(MAIL_FROM)"
      $mailTo    = "$(MAIL_TO)"

      if ($testExit -ne "0") { $status = "COM FALHAS"; } else { $status = "SUCESSO"; }

      $subject   = "Relatório Allure (Staging) - $status"

      $bodyLines = @(
        "Execução: $buildNum (ID $buildId)",
        "Status dos testes: $status (exit $testExit)",
        "Relatório: $siteUrl"
      )
      $body = $bodyLines -join "`n"

      if ($smtpUser -and $smtpPass) {
        $sec  = ConvertTo-SecureString $smtpPass -AsPlainText -Force
        $cred = New-Object System.Management.Automation.PSCredential($smtpUser, $sec)
        Send-MailMessage -From $mailFrom -To $mailTo -Subject $subject -Body $body -SmtpServer $smtpHost -Port $smtpPort -UseSsl -Credential $cred -Encoding UTF8
      } else {
        Send-MailMessage -From $mailFrom -To $mailTo -Subject $subject -Body $body -SmtpServer $smtpHost -Port $smtpPort -Encoding UTF8
      }

# Publicar TRX (sempre)
- task: PublishTestResults@2
  displayName: Publish TRX
  condition: always()
  inputs:
    testResultsFormat: VSTest
    testResultsFiles: '**/*.trx'
    searchFolder: '$(Build.SourcesDirectory)'
    failTaskOnFailedTests: false
    testRunTitle: 'NUnit TRX'
    mergeTestResults: true
    # Evita erro quando não há TRX
    # (se preferir estrito, remova)
    # -> no PublishTestResults não tem allowEmptyResults,
    #    então o searchFolder + pattern amplo já ajudam.
