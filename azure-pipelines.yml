# azure-pipelines.yml
trigger: none

pool:
  name: zportal-idsf-hmg
  demands:
  - msbuild
  - visualstudio

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'Portal-IDSF-Staging'
      trigger: true

variables:
  - group: NetlifySecrets          # NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, SITE_URL (opcional)
  - group: EmailSecrets            # SMTP_SERVER, SMTP_PORT, SMTP_USER, SMTP_PASS, MAIL_TO, MAIL_FROM
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

jobs:
# ========================= JOB 1 — TESTS =========================
- job: Tests
  displayName: "Run Playwright/NUnit tests"

  steps:
  - checkout: self

  - task: UseDotNet@2
    inputs: { packageType: 'sdk', version: '8.0.x' }

  - task: NodeTool@0
    inputs: { versionSpec: '18.x' }

  - powershell: |
      $ErrorActionPreference = 'Stop'
      $testCsproj = '$(TEST_CSPROJ)'
      dotnet clean $testCsproj -c Release
      $testDir = '$(TEST_DIR)'
      $sourceDir = '$(Build.SourcesDirectory)'
      $pathsToRemove = @(
          Join-Path $testDir 'bin'
          Join-Path $testDir 'obj'
          Join-Path $sourceDir 'TestResults'
          Join-Path $sourceDir '_allure'
          Join-Path $sourceDir '$(ALLURE_REPORT_DIR)'
      )

      foreach ($path in $pathsToRemove) {
          if (Test-Path $path) {
              Remove-Item -Path $path -Recurse -Force -ErrorAction SilentlyContinue
          }
      }

      Get-ChildItem -Path $sourceDir -Directory -Filter '$(ALLURE_RESULTS_DIR)' -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
          Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction SilentlyContinue
      }

      $allureResults = Join-Path $sourceDir '_allure\results'
      New-Item -Path $allureResults -ItemType Directory -Force | Out-Null

      $configPath = Join-Path $sourceDir 'allure.config.json'
      $config = @{
          allure = @{
              directory = $allureResults
          }
      } | ConvertTo-Json -Depth 3
      Set-Content -Path $configPath -Value $config -Encoding UTF8
    displayName: 'Clean + configurar Allure (fresh)'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      dotnet --info
      dotnet restore '$(TEST_CSPROJ)'
      dotnet build '$(TEST_CSPROJ)' -c Release --no-restore
    displayName: 'Restore + Build'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      Push-Location '$(TEST_DIR)'
      try {
          $scriptPath = Get-ChildItem -Path '.\bin' -Filter 'playwright.ps1' -File -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $scriptPath) {
              Write-Host 'ERRO: playwright.ps1 nao encontrado.'
              Get-ChildItem -Path '.\bin' -Recurse | Out-String | Write-Host
              throw 'playwright.ps1 nao encontrado.'
          }

          try {
              & $scriptPath.FullName install --with-deps
          } catch {
              Write-Warning 'Falha ao instalar com --with-deps, tentando sem dependencias adicionais.'
              & $scriptPath.FullName install
          }
      } finally {
          Pop-Location
      }
    displayName: 'Playwright browsers install'

  - powershell: |
      $ErrorActionPreference = 'Continue'
      $sourceDir = '$(Build.SourcesDirectory)'
      Write-Host "Rodando testes em: $(TEST_CSPROJ)"
      $trxPath = Join-Path $sourceDir 'TestResults\results.trx'
      dotnet test '$(TEST_CSPROJ)' -c Release `
        -l "console;verbosity=detailed" `
        --logger "trx;LogFileName=$trxPath"
      $testExit = $LASTEXITCODE

      $resultsRoot = Join-Path $sourceDir '_allure\results'
      if (-not (Test-Path $resultsRoot)) {
          New-Item -Path $resultsRoot -ItemType Directory -Force | Out-Null
      }

      $allureDirs = Get-ChildItem -Path $sourceDir -Directory -Filter '$(ALLURE_RESULTS_DIR)' -Recurse -ErrorAction SilentlyContinue |
        Where-Object { $_.FullName -ne $resultsRoot }

      foreach ($dir in $allureDirs) {
          Write-Host "Copiando resultados do Allure de: $($dir.FullName)"
          Copy-Item -Path (Join-Path $dir.FullName '*') -Destination $resultsRoot -Recurse -Force -ErrorAction SilentlyContinue
      }

      $jsonCount = (Get-ChildItem -Path $resultsRoot -Filter '*.json' -File -ErrorAction SilentlyContinue | Measure-Object).Count
      Write-Host "Allure JSONs disponiveis em $resultsRoot: $jsonCount"

      Write-Host "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$testExit"
      exit 0
    name: runTests
    displayName: 'Run tests (non-blocking)'
    env:
      ALLURE_CONFIG: $(Build.SourcesDirectory)\allure.config.json
      ALLURE_RESULTS_DIRECTORY: $(Build.SourcesDirectory)\_allure\results

  - task: PublishTestResults@2
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: 'TestResults/**/*.trx'
      searchFolder: '$(Build.SourcesDirectory)'
      failTaskOnFailedTests: false
      testRunTitle: 'NUnit TRX'
      mergeTestResults: true
    displayName: 'Publish TRX'

  # Sanity obrigatório: falha se não houver JSONs do Allure
  - powershell: |
      $ErrorActionPreference = 'Stop'
      $dir = Join-Path '$(Build.SourcesDirectory)' '_allure\results'
      Write-Host "Sanity em $dir"
      if (Test-Path $dir) {
          Get-ChildItem -Path $dir | ForEach-Object { Write-Host $_.Name }
          $count = (Get-ChildItem -Path $dir -Filter '*.json' -File | Measure-Object).Count
      } else {
          $count = 0
      }
      Write-Host "Arquivos Allure: $count"
      if ($count -eq 0) {
          throw 'ERRO: Nenhum JSON do Allure gerado. Verifique pacotes Allure.NUnit/Allure.Commons e variaveis ALLURE_CONFIG/ALLURE_RESULTS_DIRECTORY.'
      }
    displayName: 'Sanity: validar _allure/results'

  - task: PublishPipelineArtifact@1
    inputs:
      artifact: 'allure-results'
      targetPath: '$(Build.SourcesDirectory)/_allure/results'
    displayName: 'Publish artifact: allure-results'

# ========================= JOB 2 — REPORT =========================
- job: Report
  displayName: "Generate Allure + Deploy Netlify + E-mail"
  dependsOn: Tests
  condition: always()

  variables:
    TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]

  steps:
  - download: current
    artifact: 'allure-results'
    displayName: 'Download artifact: allure-results'

  - task: NodeTool@0
    inputs: { versionSpec: '18.x' }
    displayName: 'Use Node 18'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      $src = Join-Path '$(Pipeline.Workspace)' 'allure-results'
      $reportDir = '$(ALLURE_REPORT_DIR)'

      if (Test-Path $reportDir) {
          Remove-Item -Path $reportDir -Recurse -Force -ErrorAction SilentlyContinue
      }
      New-Item -Path $reportDir -ItemType Directory -Force | Out-Null

      Write-Host "Listando SRC=$src"
      if (Test-Path $src) {
          Get-ChildItem -Path $src -Filter '*.json' -File | Select-Object -First 10 | ForEach-Object { Write-Host $_.Name }
      } else {
          Write-Host 'Nenhum arquivo encontrado; diretorio de origem nao existe.'
      }

      $npxOutput = npx -y allure-commandline@2.29.0 generate --clean -o $reportDir $src 2>&1
      $exitCode = $LASTEXITCODE
      $npxOutput | Write-Host
      if ($exitCode -ne 0) {
          throw "Falha ao gerar relatorio Allure. Codigo: $exitCode"
      }

      $historyPath = Join-Path $reportDir 'history'
      if (Test-Path $historyPath) {
          Remove-Item -Path $historyPath -Recurse -Force -ErrorAction SilentlyContinue
      }
      New-Item -Path (Join-Path $reportDir '.nojekyll') -ItemType File -Force | Out-Null
      if (-not (Test-Path (Join-Path $reportDir 'index.html'))) {
          throw 'Arquivo index.html nao encontrado no diretorio do relatorio.'
      }
    displayName: 'Generate Allure report (fresh)'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      npm install -g netlify-cli
      netlify --version

      $reportDir = '$(ALLURE_REPORT_DIR)'
      $deployOutput = & netlify deploy `
        --prod `
        --dir="$reportDir" `
        --site="$(NETLIFY_SITE_ID)" `
        --auth="$(NETLIFY_AUTH_TOKEN)" `
        --message="Allure $(Build.BuildNumber)" `
        --json 2>&1
      $exitCode = $LASTEXITCODE
      $deployOutput | Write-Host
      if ($exitCode -ne 0) {
          throw "Falha no deploy Netlify. Codigo: $exitCode"
      }

      $deployJsonPath = 'deploy.json'
      $deployText = $deployOutput -join [Environment]::NewLine
      Set-Content -Path $deployJsonPath -Value $deployText -Encoding UTF8

      $json = $deployText | ConvertFrom-Json
      $url = $json.url
      if (-not $url) {
          $url = $json.deploy_url
      }
      if ($url) {
          Write-Host "##vso[task.setvariable variable=NETLIFY_URL]$url"
      } else {
          throw 'Nao foi possivel obter URL do deploy Netlify.'
      }
    displayName: 'Deploy to Netlify (prod)'

  - task: PowerShell@2
    condition: always()
    env:
      SITE_URL: $(NETLIFY_URL)
      SMTP_SERVER: $(SMTP_SERVER)
      SMTP_PORT: $(SMTP_PORT)
      SMTP_USER: $(SMTP_USER)
      SMTP_PASS: $(SMTP_PASS)
      MAIL_FROM: $(MAIL_FROM)
      MAIL_TO: $(MAIL_TO)
      TEST_EXIT: $(TEST_EXIT_FROM_PREV)
      BUILD_DEFINITIONNAME: $(Build.DefinitionName)
      BUILD_BUILDID: $(Build.BuildId)
      BUILD_BUILDNUMBER: $(Build.BuildNumber)
    inputs:
      targetType: inline
      script: |
        $siteUrl = $env:SITE_URL
        $pipeline = $env:BUILD_DEFINITIONNAME
        $buildId  = $env:BUILD_BUILDID
        $buildNum = $env:BUILD_BUILDNUMBER
        $testExit = $env:TEST_EXIT
        if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }
        $subject = "Relatório Allure (Staging) - $status"
        $body = "Pipeline: $pipeline`nExecução: $buildNum (ID $buildId)`nStatus dos testes: $status (exit $testExit)`nRelatório: $siteUrl"
        if ($env:SMTP_USER -and $env:SMTP_PASS) {
          $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
        } else {
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
        }
    displayName: 'Send email with report link'
