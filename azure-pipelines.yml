# azure-pipelines.yml
trigger: none

pool:
  name: zportal-idsf-hmg
  demands:
  - msbuild
  - visualstudio

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'Portal-IDSF-Staging'
      trigger: true

variables:
  - group: NetlifySecrets          # NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, SITE_URL (opcional)
  - group: EmailSecrets            # SMTP_SERVER, SMTP_PORT, SMTP_USER, SMTP_PASS, MAIL_TO, MAIL_FROM
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

############################
# JOB 1 — TESTS (não bloqueia)
############################
jobs:
- job: Tests
  displayName: "Run Playwright/NUnit tests"
  pool:
    vmImage: 'ubuntu-22.04'

  steps:
  - checkout: self
    displayName: 'Checkout tests repo'

  - task: UseDotNet@2
    displayName: 'Use .NET 8 SDK'
    inputs:
      packageType: 'sdk'
      version: '8.0.x'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  # LIMPEZA total e config do Allure (resultado SEMPRE novo)
  - script: |
      set -e
      dotnet clean "$(TEST_CSPROJ)" -c Release
      rm -rf "$(TEST_DIR)/bin" \
             "$(TEST_DIR)/obj" \
             "$(Build.SourcesDirectory)/TestResults" \
             "$(Build.SourcesDirectory)/_allure" \
             "$(Build.SourcesDirectory)/$(ALLURE_REPORT_DIR)"
      # remove quaisquer pastas antigas chamadas allure-results no repo
      find "$(Build.SourcesDirectory)" -type d -name "$(ALLURE_RESULTS_DIR)" -prune -exec rm -rf {} +
      # cria pasta fixa desta execução
      mkdir -p "$(Build.SourcesDirectory)/_allure/results"
      # aponta o adaptador do Allure para a pasta fixa
      cat > "$(Build.SourcesDirectory)/allure.config.json" <<EOF
      { "allure": { "directory": "$(Build.SourcesDirectory)/_allure/results" } }
      EOF
    displayName: 'Clean + configurar Allure (executa sempre do zero)'

  - script: |
      set -e
      dotnet --info
      dotnet restore "$(TEST_CSPROJ)"
      dotnet build   "$(TEST_CSPROJ)" -c Release --no-restore
    displayName: 'Restore + Build'

  - script: |
      set -e
      cd "$(TEST_DIR)"
      SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
      if [ -z "$SCRIPT_PATH" ]; then
        echo "ERRO: playwright.ps1 não encontrado após o build."
        ls -R ./bin || true
        exit 1
      fi
      pwsh "$SCRIPT_PATH" install --with-deps || pwsh "$SCRIPT_PATH" install
    displayName: 'Playwright browsers install'

  # Executa testes e NÃO falha o job
  - script: |
      set +e
      echo "Rodando testes em: $(TEST_CSPROJ)"
      dotnet test "$(TEST_CSPROJ)" -c Release \
        --logger "trx;LogFileName=$(Build.SourcesDirectory)/TestResults/results.trx"
      TEST_EXIT=$?
      echo "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$TEST_EXIT"
      echo "Conteúdo em _allure/results:"
      ls -la "$(Build.SourcesDirectory)/_allure/results" || true
      exit 0
    name: runTests
    displayName: 'Run tests (non-blocking)'
    env:
      ALLURE_CONFIG: $(Build.SourcesDirectory)/allure.config.json
      ALLURE_RESULTS_DIRECTORY: $(Build.SourcesDirectory)/_allure/results

  - task: PublishTestResults@2
    displayName: 'Publish TRX'
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: 'TestResults/**/*.trx'
      searchFolder: '$(Build.SourcesDirectory)'
      failTaskOnFailedTests: false
      testRunTitle: 'NUnit TRX'
      mergeTestResults: true

  # Publica SOMENTE os resultados da pasta fixa (sem fallback)
  - task: PublishPipelineArtifact@1
    displayName: 'Publish artifact: allure-results'
    inputs:
      artifact: 'allure-results'
      targetPath: '$(Build.SourcesDirectory)/_allure/results'

############################
# JOB 2 — REPORT (sempre roda)
############################
- job: Report
  displayName: "Generate Allure + Deploy Netlify + E-mail"
  pool:
    vmImage: 'ubuntu-22.04'
  dependsOn: Tests
  condition: always()

  variables:
    TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]

  steps:
  - download: current
    displayName: 'Download artifact: allure-results'
    artifact: 'allure-results'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  # Gera relatório LIMPO sempre e impede cache
  - script: |
      set -e
      SRC="$(Pipeline.Workspace)/allure-results"
      rm -rf "$(ALLURE_REPORT_DIR)"
      mkdir -p "$(ALLURE_REPORT_DIR)"

      if [ -d "$SRC" ] && [ -n "$(ls -A "$SRC" 2>/dev/null)" ]; then
        npx -y allure-commandline@2.29.0 generate --clean -o "$(ALLURE_REPORT_DIR)" "$SRC"
      else
        echo '<!doctype html><html lang="pt-br"><meta charset="utf-8"><title>Allure</title><body style="font-family:sans-serif;padding:24px"><h1>Sem resultados nesta execução</h1></body></html>' > "$(ALLURE_REPORT_DIR)/index.html"
      fi

      # NÃO carregar histórico antigo -> data/hora sempre atual
      rm -rf "$(ALLURE_REPORT_DIR)/history" || true
      find "$(ALLURE_REPORT_DIR)" -type f -name 'history.json' -delete || true
      find "$(ALLURE_REPORT_DIR)" -type f -name '*history-trend*.json' -delete || true

      # anticache no Netlify e bloqueia Jekyll
      printf '/*\n  Cache-Control: no-store, no-cache, must-revalidate, max-age=0\n  Pragma: no-cache\n  Expires: 0\n' > "$(ALLURE_REPORT_DIR)/_headers"
      touch "$(ALLURE_REPORT_DIR)/.nojekyll"

      # sanity check
      test -f "$(ALLURE_REPORT_DIR)/index.html" || { echo "ERRO: index.html não gerado"; exit 1; }
    displayName: 'Generate Allure report (fresh)'

  # Deploy PROD no Netlify apontando para allure-report/
  - script: |
      set -e
      npm i -g netlify-cli
      netlify --version

      netlify deploy \
        --prod \
        --dir="$(ALLURE_REPORT_DIR)" \
        --site "$(NETLIFY_SITE_ID)" \
        --auth "$(NETLIFY_AUTH_TOKEN)" \
        --message "Allure $(Build.BuildNumber)" \
        --json > deploy.json

      echo "======== Netlify Deploy Result ========"
      cat deploy.json

      URL=$(node -e "let d='';process.stdin.on('data',c=>d+=c).on('end',()=>{try{let j=JSON.parse(d);console.log(j.url||j.deploy_url||'');}catch(e){process.exit(1)}})" < deploy.json)
      echo "##vso[task.setvariable variable=NETLIFY_URL]$URL"
    displayName: 'Deploy to Netlify (prod)'

  - task: PowerShell@2
    displayName: 'Send email with report link'
    condition: always()
    env:
      SITE_URL: $(NETLIFY_URL)          # usa a URL publicada desta execução
      SMTP_SERVER: $(SMTP_SERVER)
      SMTP_PORT: $(SMTP_PORT)
      SMTP_USER: $(SMTP_USER)
      SMTP_PASS: $(SMTP_PASS)
      MAIL_FROM: $(MAIL_FROM)
      MAIL_TO: $(MAIL_TO)
      TEST_EXIT: $(TEST_EXIT_FROM_PREV)
      BUILD_DEFINITIONNAME: $(Build.DefinitionName)
      BUILD_BUILDID: $(Build.BuildId)
      BUILD_BUILDNUMBER: $(Build.BuildNumber)
    inputs:
      targetType: inline
      script: |
        $siteUrl = $env:SITE_URL
        $pipeline = $env:BUILD_DEFINITIONNAME
        $buildId  = $env:BUILD_BUILDID
        $buildNum = $env:BUILD_BUILDNUMBER
        $testExit = $env:TEST_EXIT
        if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }
        $subject = "Relatório Allure (Staging) - $status"
        $body = "Pipeline: $pipeline`nExecução: $buildNum (ID $buildId)`nStatus dos testes: $status (exit $testExit)`nRelatório: $siteUrl"
        if ($env:SMTP_USER -and $env:SMTP_PASS) {
          $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
        } else {
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
        }
