# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true

pool:
  vmImage: 'ubuntu-latest'

variables:
  - group: NetlifySecrets          # NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, SITE_URL
  - group: EmailSecrets            # SMTP_SERVER, SMTP_PORT, SMTP_USER, SMTP_PASS, MAIL_TO, MAIL_FROM
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'
  # Mantenha essa versão igual ao PackageReference Microsoft.Playwright do seu .csproj
  - name: PLAYWRIGHT_VERSION
    value: '1.46.0'

steps:
  - checkout: self
    displayName: 'Checkout tests repo'

  - task: UseDotNet@2
    displayName: 'Use .NET 8 SDK'
    inputs:
      packageType: 'sdk'
      version: '8.0.x'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  # Restore e BUILD antes de instalar browsers
  - script: |
      set -e
      dotnet --info
      dotnet restore "$(TEST_CSPROJ)"
      dotnet build "$(TEST_CSPROJ)" -c Release --no-restore
    displayName: 'Restore + Build'

  # Instala Playwright CLI (versão alinhada) e adiciona ao PATH
  - script: |
      set -e
      dotnet tool install --global Microsoft.Playwright.CLI --version $(PLAYWRIGHT_VERSION)
      echo "##vso[task.prependpath]$HOME/.dotnet/tools"
    displayName: 'Install Playwright CLI'

  # Instala browsers DENTRO do diretório do projeto de testes
  - script: |
      set -e
      cd "$(TEST_DIR)"
      playwright install --with-deps
    displayName: 'Playwright browsers install'

  # Executa testes
  - script: |
      set -e
      echo "Rodando testes em: $(TEST_CSPROJ)"
      dotnet test "$(TEST_CSPROJ)" -c Release --logger "trx"
    displayName: 'Run tests'

  # Gera Allure (garante que há resultados)
  - script: |
      set -e
      npm i -g allure-commandline netlify-cli

      # Se os resultados forem gerados dentro do bin, copie para a raiz esperada
      # Ajuste o caminho abaixo se usa outro framework/target
      RESULTS_FROM=$(find "$(TEST_DIR)/bin/Release" -type d -name "$(ALLURE_RESULTS_DIR)" | head -n 1 || true)
      if [ -n "$RESULTS_FROM" ] && [ ! -d "$(ALLURE_RESULTS_DIR)" ]; then
        cp -r "$RESULTS_FROM" "./$(ALLURE_RESULTS_DIR)"
      fi

      if [ ! -d "$(ALLURE_RESULTS_DIR)" ]; then
        echo "ERROR: pasta '$(ALLURE_RESULTS_DIR)' não encontrada. Configure o adapter Allure para emitir nessa pasta."
        exit 1
      fi

      allure generate --clean -o "$(ALLURE_REPORT_DIR)" "$(ALLURE_RESULTS_DIR)"
    displayName: 'Generate Allure report'

  # Deploy no Netlify (mantém link fixo)
  - script: |
      set -e
      netlify deploy \
        --prod \
        --dir="$(ALLURE_REPORT_DIR)" \
        --site "$(NETLIFY_SITE_ID)" \
        --auth "$(NETLIFY_AUTH_TOKEN)" \
        --json > deploy.json

      echo "======== Netlify Deploy Result ========"
      cat deploy.json || true
    displayName: 'Deploy to Netlify (prod)'

  # Envia e-mail com o link fixo do site
  - task: PowerShell@2
    displayName: 'Send email with report link'
    inputs:
      targetType: 'inline'
      script: |
        $siteUrl   = "$(SITE_URL)"
        $smtpHost  = "$(SMTP_SERVER)"
        $smtpPort  = [int]"$(SMTP_PORT)"
        $smtpUser  = "$(SMTP_USER)"
        $smtpPass  = "$(SMTP_PASS)"
        $mailFrom  = "$(MAIL_FROM)"
        $mailTo    = "$(MAIL_TO)"

        $subject = "Allure - Execução $(Build.BuildNumber)"
        $body = "Olá, time!`n`nO relatório Allure da execução $(Build.BuildNumber) está disponível em:`n$siteUrl`n`nPipeline: $(Build.DefinitionName)`nExecução: $(Build.BuildId)"

        if ($smtpUser -and $smtpPass) {
          $sec = ConvertTo-SecureString $smtpPass -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential($smtpUser, $sec)
          Send-MailMessage -From $mailFrom -To $mailTo -Subject $subject -Body $body -SmtpServer $smtpHost -Port $smtpPort -UseSsl -Credential $cred
        } else {
          Send-MailMessage -From $mailFrom -To $mailTo -Subject $subject -Body $body -SmtpServer $smtpHost -Port $smtpPort
        }

  - task: PublishTestResults@2
    displayName: 'Publish TRX'
    inputs:
      testResultsFormat: 'VSTest'
      testResultsFiles: '**/*.trx'
      failTaskOnFailedTests: true
