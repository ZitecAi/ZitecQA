trigger: none

pool:
  name: zportal-idsf-hmg
  demands:
  - msbuild
  - visualstudio

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'Portal-IDSF-Staging'
      trigger: true

variables:
  - group: NetlifySecrets          # GITHUB_PAGES_REPO, GITHUB_PAGES_TOKEN, SITE_URL
  - group: EmailSecrets
  - group: PortalSecrets
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

jobs:
- job: AllurePipeline
  displayName: "Tests + Allure + GitHub Pages + Email (single job)"
  steps:
  - checkout: self

  - powershell: |
      $now = [DateTime]::UtcNow.ToString("o")
      Write-Host "##vso[task.setvariable variable=PIPE_START_UTC]$now"
    displayName: 'Mark pipeline start time (UTC)'

  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '8.0.x'

  - task: NodeTool@0
    inputs:
      versionSpec: '18.x'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      $testCsproj = '$(TEST_CSPROJ)'
      $testDir = '$(TEST_DIR)'
      $sourceDir = '$(Build.SourcesDirectory)'

      dotnet clean $testCsproj -c Release

      @(
        Join-Path $testDir 'bin'
        Join-Path $testDir 'obj'
        Join-Path $sourceDir 'TestResults'
        Join-Path $sourceDir '_allure'
        Join-Path $sourceDir '$(ALLURE_REPORT_DIR)'
      ) | ForEach-Object {
        if (Test-Path $_) { Remove-Item -Recurse -Force $_ }
      }

      $allureResults = Join-Path $testDir 'bin\Release\net8.0\allure-results'
      New-Item -Path $allureResults -ItemType Directory -Force | Out-Null

      $configPath = Join-Path $testDir 'allureConfig.json'
      $config = @{ allure = @{ directory = 'allure-results' } } | ConvertTo-Json -Depth 3
      Set-Content -Path $configPath -Value $config -Encoding UTF8
    displayName: 'Clean e configurar Allure (fresh)'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      dotnet --info
      dotnet restore '$(TEST_CSPROJ)'
      dotnet build '$(TEST_CSPROJ)' -c Release --no-restore
    displayName: 'Restore + Build'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      Push-Location '$(TEST_DIR)'
      try {
        $scriptPath = Get-ChildItem -Path '.\bin' -Filter 'playwright.ps1' -File -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
        if (-not $scriptPath) { throw 'playwright.ps1 nao encontrado.' }

        try {
          & $scriptPath.FullName install --with-deps
        } catch {
          & $scriptPath.FullName install
        }
      }
      finally {
        Pop-Location
      }
    displayName: 'Playwright browsers install'

  - powershell: |
      $ErrorActionPreference = 'Continue'
      $sourceDir = '$(Build.SourcesDirectory)'
      $trxPath = Join-Path $sourceDir 'TestResults\results.trx'

      dotnet test '$(TEST_CSPROJ)' -c Release -l "console;verbosity=detailed" --logger "trx;LogFileName=$trxPath"
      $testExit = $LASTEXITCODE
      Write-Host "##vso[task.setvariable variable=TEST_EXIT]$testExit"

      exit 0
    displayName: 'Run tests (non-blocking)'

  - task: PublishTestResults@2
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: 'TestResults/**/*.trx'
      searchFolder: '$(Build.SourcesDirectory)'
      failTaskOnFailedTests: false
      testRunTitle: 'NUnit TRX'
      mergeTestResults: true
    displayName: 'Publish TRX'

  - powershell: |
      $ErrorActionPreference = 'Stop'
      $sourceDir = '$(Build.SourcesDirectory)'
      $testDir = '$(TEST_DIR)'

      $pipeStartStr = $env:PIPE_START_UTC
      if ([string]::IsNullOrWhiteSpace($pipeStartStr)) {
        $pipeStart = [DateTime]::UtcNow.AddHours(-12)
      } else {
        $pipeStart = [DateTime]::ParseExact(
          $pipeStartStr,
          "o",
          [Globalization.CultureInfo]::InvariantCulture,
          [Globalization.DateTimeStyles]::AssumeUniversal
        )
      }

      $src = Join-Path $testDir 'bin\Release\net8.0\allure-results'
      $destRoot = Join-Path $sourceDir '_allure\results'

      if (Test-Path $destRoot) { Remove-Item -Recurse -Force $destRoot }
      New-Item -ItemType Directory -Path $destRoot -Force | Out-Null

      if (-not (Test-Path $src)) { throw "Diretorio de resultados nao encontrado: $src" }

      $files = Get-ChildItem -Path $src -File -Recurse | Where-Object { $_.LastWriteTimeUtc -ge $pipeStart }
      if (($files | Measure-Object).Count -eq 0) {
        $files = Get-ChildItem -Path $src -File -Recurse
      }

      $files | ForEach-Object { Copy-Item -Path $_.FullName -Destination $destRoot -Force }

      $jsonCount = (Get-ChildItem -Path $destRoot -Filter '*.json' -File | Measure-Object).Count
      if ($jsonCount -eq 0) { throw 'Nenhum JSON do Allure gerado para esta execucao.' }
    displayName: 'Consolidar apenas resultados da execucao atual'

  - powershell: |
      Write-Host "Iniciando instalacao Java JDK 11"

      $jdkUrl      = "https://github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.23%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.23_9.zip"
      $jdkZipPath  = "$(Agent.TempDirectory)\jdk11.zip"
      $javaHome    = "$(Agent.TempDirectory)\jdk11"

      Invoke-WebRequest -Uri $jdkUrl -OutFile $jdkZipPath

      if (Test-Path $javaHome) { Remove-Item -Recurse -Force $javaHome }

      Expand-Archive -Path $jdkZipPath -DestinationPath "$(Agent.TempDirectory)"

      $extractedFolder = Get-ChildItem -Path "$(Agent.TempDirectory)" -Directory -Filter "jdk-11*" | Select-Object -First 1
      if (-not $extractedFolder) { throw "Falha na extracao do JDK" }

      Rename-Item -Path $extractedFolder.FullName -NewName "jdk11"

      Write-Host "##vso[task.setvariable variable=JAVA_HOME]$javaHome"
      Write-Host "##vso[task.prependpath]$($javaHome)\bin"
    displayName: 'Install Java JDK 11'

  - powershell: |
      java -version
    displayName: 'Verify Java'

  - task: NodeTool@0
    inputs:
      versionSpec: '18.x'
    displayName: 'Use Node 18'

  - powershell: |
      $ErrorActionPreference = 'Stop'

      $src       = Join-Path '$(Build.SourcesDirectory)' '_allure\results'
      $reportDir = '$(ALLURE_REPORT_DIR)'

      if (Test-Path $reportDir) { Remove-Item -Recurse -Force $reportDir }
      New-Item -Path $reportDir -ItemType Directory -Force | Out-Null

      $npxOutput = npx -y allure-commandline@2.29.0 generate --clean -o $reportDir $src 2>&1
      $exitCode  = $LASTEXITCODE

      $npxOutput | Write-Host

      if ($exitCode -ne 0) { throw "Falha ao gerar relatorio Allure. Codigo: $exitCode" }

      $historyPath = Join-Path $reportDir 'history'
      if (Test-Path $historyPath) { Remove-Item -Recurse -Force $historyPath }

      New-Item -Path (Join-Path $reportDir '.nojekyll') -ItemType File -Force | Out-Null

      if (-not (Test-Path (Join-Path $reportDir 'index.html'))) {
        throw 'index.html nao encontrado'
      }
    displayName: 'Generate Allure report'

  - powershell: |
      $ErrorActionPreference = 'Stop'

      $repoUrl = '$(GITHUB_PAGES_REPO)'
      $token   = '$(GITHUB_PAGES_TOKEN)'

      if ([string]::IsNullOrWhiteSpace($repoUrl)) { throw "GITHUB_PAGES_REPO nao configurado." }
      if ([string]::IsNullOrWhiteSpace($token))   { throw "GITHUB_PAGES_TOKEN nao configurado." }

      if ($repoUrl.StartsWith('https://')) {
        $authUrl = $repoUrl.Replace('https://', "https://$token@")
      } else {
        $authUrl = "https://$token@$repoUrl"
      }

      $workDir = Join-Path "$(Agent.TempDirectory)" "gh-pages-work"
      if (Test-Path $workDir) { Remove-Item -Recurse -Force $workDir }

      git clone $authUrl $workDir

      Push-Location $workDir
      try {
        git config user.name  "zitec-qa-bot"
        git config user.email "qa-bot@zitec.ai"

        $hasGhPages = git branch -r | Select-String 'origin/gh-pages' -ErrorAction SilentlyContinue
        if ($hasGhPages) {
          git checkout gh-pages
        } else {
          git checkout --orphan gh-pages
        }

        $gitignoreBackup = Join-Path $workDir "..\gitignore.bak"
        if (Test-Path ".gitignore") {
          Copy-Item ".gitignore" $gitignoreBackup -Force
        }

        Get-ChildItem -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force

        $reportDir = Join-Path '$(Build.SourcesDirectory)' '$(ALLURE_REPORT_DIR)'
        Copy-Item "$reportDir\*" $workDir -Recurse -Force

        if (Test-Path $gitignoreBackup) {
          Copy-Item $gitignoreBackup (Join-Path $workDir ".gitignore") -Force
        }

        git add .

        $hadCommit = $true
        git commit -m "Allure report $(Build.BuildNumber)" 2>$null
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Nenhuma alteracao para commitar em gh-pages."
          $hadCommit = $false
        }

        if ($hadCommit) {
          git push origin gh-pages --force
        } else {
          Write-Host "Pulando git push pois nao ha alteracoes."
        }
      }
      finally {
        Pop-Location
      }
    displayName: 'Deploy Allure to GitHub Pages (gh-pages)'
    env:
      GITHUB_PAGES_TOKEN: $(GITHUB_PAGES_TOKEN)
      GITHUB_PAGES_REPO: $(GITHUB_PAGES_REPO)

  - task: PowerShell@2
    condition: always()
    env:
      SITE_URL: $(SITE_URL)
      SMTP_SERVER: $(SMTP_SERVER)
      SMTP_PORT: $(SMTP_PORT)
      SMTP_USER: $(SMTP_USER)
      SMTP_PASS: $(SMTP_PASS)
      MAIL_FROM: $(MAIL_FROM)
      MAIL_TO: $(MAIL_TO)
      TEST_EXIT: $(TEST_EXIT)
      BUILD_DEFINITIONNAME: $(Build.DefinitionName)
      BUILD_BUILDID: $(Build.BuildId)
      BUILD_BUILDNUMBER: $(Build.BuildNumber)
    inputs:
      targetType: inline
      script: |
        $siteUrl = $env:SITE_URL
        $pipeline = $env:BUILD_DEFINITIONNAME
        $buildId  = $env:BUILD_BUILDID
        $buildNum = $env:BUILD_BUILDNUMBER
        $testExit = $env:TEST_EXIT

        if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }
        $subject = "Relatorio Allure (Staging) - $status"

        $body = "Pipeline: $pipeline`nExecucao: $buildNum (ID $buildId)`nStatus dos testes: $status (exit $testExit)`nRelatorio: $siteUrl"

        $recipients = $env:MAIL_TO -split '[,;]' | ForEach-Object { $_.Trim() } | Where-Object { $_ }

        if ($env:SMTP_USER -and $env:SMTP_PASS) {
        $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
        $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
        Send-MailMessage -From $env:MAIL_FROM -To $recipients -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
        } else {
        Send-MailMessage -From $env:MAIL_FROM -To $recipients -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
        }
    displayName: 'Send email with report link'
