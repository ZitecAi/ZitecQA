# azure-pipelines.yml
trigger: none

resources:
  pipelines:
    - pipeline: AppDeploy
      project: 'Dev-ops IDSF'
      source: 'ZIDSF - PORTAL - STAGING'
      trigger: true

variables:
  - group: NetlifySecrets          # NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, SITE_URL
  - group: EmailSecrets            # SMTP_SERVER, SMTP_PORT, SMTP_USER, SMTP_PASS, MAIL_TO, MAIL_FROM
  - name: TEST_CSPROJ
    value: 'PortalIDSFTestes/PortalIDSFTestes.csproj'
  - name: TEST_DIR
    value: 'PortalIDSFTestes'
  - name: ALLURE_RESULTS_DIR
    value: 'allure-results'
  - name: ALLURE_REPORT_DIR
    value: 'allure-report'

############################
# JOB 1 — TESTS (não bloqueia)
############################
jobs:
- job: Tests
  displayName: "Run Playwright/NUnit tests"
  pool:
    vmImage: 'ubuntu-22.04'

  steps:
  - checkout: self
    displayName: 'Checkout tests repo'

  - task: UseDotNet@2
    displayName: 'Use .NET 8 SDK'
    inputs:
      packageType: 'sdk'
      version: '8.0.x'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  # Limpa build antigo e QUALQUER allure-results residual
  - script: |
      set -e
      dotnet clean "$(TEST_CSPROJ)" -c Release
      rm -rf "$(TEST_DIR)/bin" \
             "$(TEST_DIR)/obj" \
             "$(Build.SourcesDirectory)/TestResults" \
             "$(Build.SourcesDirectory)/_allure"
      # remove pastas allure-results perdidas no repo
      find "$(Build.SourcesDirectory)" -type d -name "allure-results" -prune -exec rm -rf {} +
    displayName: 'Clean bin/obj/TestResults + varrer allure-results antigos'

  # Cria allure.config.json com diretório ABSOLUTO e prepara pasta de resultados
  - script: |
      set -e
      mkdir -p "$(Build.SourcesDirectory)/_allure/results"
      printf '%s\n' \
        '{' \
        '  "allure": {' \
        "    \"directory\": \"$(Build.SourcesDirectory)/_allure/results\"" \
        '  }' \
        '}' > "$(Build.SourcesDirectory)/allure.config.json"
      echo "Allure config em: $(Build.SourcesDirectory)/allure.config.json"
    displayName: 'Configurar Allure (path absoluto)'

  - script: |
      set -e
      dotnet --info
      dotnet restore "$(TEST_CSPROJ)"
      dotnet build "$(TEST_CSPROJ)" -c Release --no-restore
    displayName: 'Restore + Build'

  - script: |
      set -e
      cd "$(TEST_DIR)"

      SCRIPT_PATH="$(find ./bin -type f -name 'playwright.ps1' | head -n 1 || true)"
      if [ -z "$SCRIPT_PATH" ]; then
        echo "ERRO: playwright.ps1 não encontrado após o build."
        ls -R ./bin || true
        exit 1
      fi

      echo "Usando script: $SCRIPT_PATH"
      if ! pwsh "$SCRIPT_PATH" install --with-deps; then
        echo "Aviso: --with-deps falhou. Tentando 'install' sem deps..."
        pwsh "$SCRIPT_PATH" install
      fi
    displayName: 'Playwright browsers install (project script)'

  # Roda testes, grava Allure na pasta fixa e SEMPRE sai 0
  - script: |
      set +e
      echo "Rodando testes em: $(TEST_CSPROJ)"
      dotnet test "$(TEST_CSPROJ)" -c Release \
        --logger "trx;LogFileName=$(Build.SourcesDirectory)/TestResults/results.trx"
      TEST_EXIT=$?
      echo "Exit code dos testes: $TEST_EXIT"
      echo "##vso[task.setvariable variable=TEST_EXIT;isOutput=true]$TEST_EXIT"

      echo "Conteúdo em _allure/results:"
      ls -la "$(Build.SourcesDirectory)/_allure/results" || true
      grep -R --include='*.json' -m 1 '"start"' "$(Build.SourcesDirectory)/_allure/results" || true

      if [ "$TEST_EXIT" -ne 0 ]; then
        echo "##vso[task.complete result=SucceededWithIssues;]Há testes falhando, mas o fluxo continuará."
      fi

      exit 0
    name: runTests
    displayName: 'Run tests (non-blocking)'
    env:
      ALLURE_CONFIG: $(Build.SourcesDirectory)/allure.config.json
      ALLURE_RESULTS_DIRECTORY: $(Build.SourcesDirectory)/_allure/results

  - task: PublishTestResults@2
    displayName: Publish TRX
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: 'TestResults/**/*.trx'
      searchFolder: '$(Build.SourcesDirectory)'
      failTaskOnFailedTests: false
      testRunTitle: 'NUnit TRX'
      mergeTestResults: true

  # Publica a pasta fixa de resultados (sem copiar de bin/Release)
  - task: PublishPipelineArtifact@1
    displayName: 'Publish artifact: allure-results'
    inputs:
      artifact: 'allure-results'
      targetPath: '$(Build.SourcesDirectory)/_allure/results'

############################
# JOB 2 — REPORT (sempre roda)
############################
- job: Report
  displayName: "Generate & publish Allure + Send email"
  pool:
    vmImage: 'ubuntu-22.04'
  dependsOn: Tests
  condition: always()

  variables:
    TEST_EXIT_FROM_PREV: $[ dependencies.Tests.outputs['runTests.TEST_EXIT'] ]

  steps:
  - download: current
    displayName: 'Download artifact: allure-results'
    artifact: 'allure-results'

  - task: NodeTool@0
    displayName: 'Use Node 18'
    inputs:
      versionSpec: '18.x'

  - script: |
      set -e
      npm i -g allure-commandline netlify-cli

      SRC="$(Pipeline.Workspace)/allure-results"
      OUT="$(ALLURE_REPORT_DIR)"

      # recria diretório do relatório do zero
      rm -rf "$OUT"
      mkdir -p "$OUT"

      if [ -d "$SRC" ] && [ "$(ls -A "$SRC" 2>/dev/null)" ]; then
        echo "Gerando Allure a partir do artifact..."
        allure generate --clean -o "$OUT" "$SRC" || true
      fi

      # remove histórico para não herdar datas/graphs antigos
      rm -rf "$OUT/history" || true
      find "$OUT" -type f -name 'history.json' -delete || true
      find "$OUT" -type f -name '*history-trend*.json' -delete || true

      # cria _headers com indentação correta (Netlify no-cache)
      {
        echo '/*'
        echo '  Cache-Control: no-store, no-cache, must-revalidate, max-age=0'
        echo '  Pragma: no-cache'
        echo '  Expires: 0'
      } > "$OUT/_headers"

      # placeholder se ainda assim ficou vazio
      if [ -z "$(ls -A "$OUT" 2>/dev/null)" ]; then
        printf '%s\n' \
          '<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Allure - Placeholder</title></head><body style="font-family:Arial,Helvetica,sans-serif;padding:24px"><h1>Allure Report</h1><p>Não há resultados de teste disponíveis para esta execução, ou a geração do Allure falhou.</p></body></html>' \
          > "$OUT/index.html"
      fi
    displayName: 'Generate Allure report (from artifact) + no-cache headers'
    condition: always()

  - script: |
      set -e
      netlify deploy \
        --prod \
        --dir="$(ALLURE_REPORT_DIR)" \
        --site "$(NETLIFY_SITE_ID)" \
        --auth "$(NETLIFY_AUTH_TOKEN)" \
        --json > deploy.json

      echo "======== Netlify Deploy Result ========"
      cat deploy.json || true

      # Extrai URL preferindo deploy_ssl_url -> deploy_url -> url -> site_url
      URL=$(node -e "let d=require('fs').readFileSync('deploy.json','utf8');let j=JSON.parse(d);console.log(j.deploy_ssl_url||j.deploy_url||j.url||j.site_url||'');")
      echo "##vso[task.setvariable variable=NETLIFY_URL]$URL"
      echo "Publicado em: $URL"
    displayName: 'Deploy to Netlify (prod)'
    condition: always()

  # Purga cache da CDN do Netlify (defensivo)
  - script: |
      set -e
      netlify api purgeCache --auth "$(NETLIFY_AUTH_TOKEN)" \
        --data '{"site_id":"'"$(NETLIFY_SITE_ID)"'"}' || true
    displayName: 'Purge Netlify CDN cache'
    condition: always()

  - task: PowerShell@2
    displayName: 'Send email with report link (plain text)'
    condition: always()
    env:
      SITE_URL: $(SITE_URL)            # do Variable Group
      NETLIFY_URL: $(NETLIFY_URL)      # do passo Netlify acima
      SMTP_SERVER: $(SMTP_SERVER)
      SMTP_PORT: $(SMTP_PORT)
      SMTP_USER: $(SMTP_USER)
      SMTP_PASS: $(SMTP_PASS)
      MAIL_FROM: $(MAIL_FROM)
      MAIL_TO: $(MAIL_TO)
      TEST_EXIT: $(TEST_EXIT_FROM_PREV)
      BUILD_DEFINITIONNAME: $(Build.DefinitionName)
      BUILD_BUILDID: $(Build.BuildId)
      BUILD_BUILDNUMBER: $(Build.BuildNumber)
    inputs:
      targetType: inline
      script: |
        $siteUrl = $env:NETLIFY_URL
        if ([string]::IsNullOrWhiteSpace($siteUrl)) { $siteUrl = $env:SITE_URL }

        $pipeline = $env:BUILD_DEFINITIONNAME
        $buildId  = $env:BUILD_BUILDID
        $buildNum = $env:BUILD_BUILDNUMBER
        $testExit = $env:TEST_EXIT
        if ($testExit -ne "0") { $status = "COM FALHAS" } else { $status = "SUCESSO" }

        $subject = "Relatório Allure (Staging) - $status"
        $bodyLines = @(
          "Pipeline: $pipeline",
          "Execução: $buildNum (ID $buildId)",
          "Status dos testes: $status (exit $testExit)",
          "Relatório: $siteUrl"
        )
        $body = $bodyLines -join "`n"

        if ($env:SMTP_USER -and $env:SMTP_PASS) {
          $sec  = ConvertTo-SecureString $env:SMTP_PASS -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential($env:SMTP_USER, $sec)
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -UseSsl -Credential $cred -Encoding UTF8
        } else {
          Send-MailMessage -From $env:MAIL_FROM -To $env:MAIL_TO -Subject $subject -Body $body -SmtpServer $env:SMTP_SERVER -Port ([int]$env:SMTP_PORT) -Encoding UTF8
        }
